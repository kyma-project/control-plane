// Code generated by mockery v2.6.0. DO NOT EDIT.

package automock

import (
	types "github.com/Peripli/service-manager-cli/pkg/types"
	servicemanager "github.com/kyma-project/control-plane/components/kyma-environment-broker/internal/servicemanager"
	mock "github.com/stretchr/testify/mock"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// Bind provides a mock function with given fields: instanceKey, bindingID, parameters, acceptsIncomplete
func (_m *Client) Bind(instanceKey servicemanager.InstanceKey, bindingID string, parameters interface{}, acceptsIncomplete bool) (*servicemanager.BindingResponse, error) {
	ret := _m.Called(instanceKey, bindingID, parameters, acceptsIncomplete)

	var r0 *servicemanager.BindingResponse
	if rf, ok := ret.Get(0).(func(servicemanager.InstanceKey, string, interface{}, bool) *servicemanager.BindingResponse); ok {
		r0 = rf(instanceKey, bindingID, parameters, acceptsIncomplete)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*servicemanager.BindingResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(servicemanager.InstanceKey, string, interface{}, bool) error); ok {
		r1 = rf(instanceKey, bindingID, parameters, acceptsIncomplete)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Deprovision provides a mock function with given fields: instanceKey, acceptsIncomplete
func (_m *Client) Deprovision(instanceKey servicemanager.InstanceKey, acceptsIncomplete bool) (*servicemanager.DeprovisionResponse, error) {
	ret := _m.Called(instanceKey, acceptsIncomplete)

	var r0 *servicemanager.DeprovisionResponse
	if rf, ok := ret.Get(0).(func(servicemanager.InstanceKey, bool) *servicemanager.DeprovisionResponse); ok {
		r0 = rf(instanceKey, acceptsIncomplete)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*servicemanager.DeprovisionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(servicemanager.InstanceKey, bool) error); ok {
		r1 = rf(instanceKey, acceptsIncomplete)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LastInstanceOperation provides a mock function with given fields: key, operationID
func (_m *Client) LastInstanceOperation(key servicemanager.InstanceKey, operationID string) (servicemanager.LastOperationResponse, error) {
	ret := _m.Called(key, operationID)

	var r0 servicemanager.LastOperationResponse
	if rf, ok := ret.Get(0).(func(servicemanager.InstanceKey, string) servicemanager.LastOperationResponse); ok {
		r0 = rf(key, operationID)
	} else {
		r0 = ret.Get(0).(servicemanager.LastOperationResponse)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(servicemanager.InstanceKey, string) error); ok {
		r1 = rf(key, operationID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOfferings provides a mock function with given fields:
func (_m *Client) ListOfferings() (*types.ServiceOfferings, error) {
	ret := _m.Called()

	var r0 *types.ServiceOfferings
	if rf, ok := ret.Get(0).(func() *types.ServiceOfferings); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ServiceOfferings)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListOfferingsByName provides a mock function with given fields: name
func (_m *Client) ListOfferingsByName(name string) (*types.ServiceOfferings, error) {
	ret := _m.Called(name)

	var r0 *types.ServiceOfferings
	if rf, ok := ret.Get(0).(func(string) *types.ServiceOfferings); ok {
		r0 = rf(name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ServiceOfferings)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPlansByName provides a mock function with given fields: planName, offeringID
func (_m *Client) ListPlansByName(planName string, offeringID string) (*types.ServicePlans, error) {
	ret := _m.Called(planName, offeringID)

	var r0 *types.ServicePlans
	if rf, ok := ret.Get(0).(func(string, string) *types.ServicePlans); ok {
		r0 = rf(planName, offeringID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.ServicePlans)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(planName, offeringID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Provision provides a mock function with given fields: brokerID, request, acceptsIncomplete
func (_m *Client) Provision(brokerID string, request servicemanager.ProvisioningInput, acceptsIncomplete bool) (*servicemanager.ProvisionResponse, error) {
	ret := _m.Called(brokerID, request, acceptsIncomplete)

	var r0 *servicemanager.ProvisionResponse
	if rf, ok := ret.Get(0).(func(string, servicemanager.ProvisioningInput, bool) *servicemanager.ProvisionResponse); ok {
		r0 = rf(brokerID, request, acceptsIncomplete)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*servicemanager.ProvisionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, servicemanager.ProvisioningInput, bool) error); ok {
		r1 = rf(brokerID, request, acceptsIncomplete)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Unbind provides a mock function with given fields: instanceKey, bindingID, acceptsIncomplete
func (_m *Client) Unbind(instanceKey servicemanager.InstanceKey, bindingID string, acceptsIncomplete bool) (*servicemanager.DeprovisionResponse, error) {
	ret := _m.Called(instanceKey, bindingID, acceptsIncomplete)

	var r0 *servicemanager.DeprovisionResponse
	if rf, ok := ret.Get(0).(func(servicemanager.InstanceKey, string, bool) *servicemanager.DeprovisionResponse); ok {
		r0 = rf(instanceKey, bindingID, acceptsIncomplete)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*servicemanager.DeprovisionResponse)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(servicemanager.InstanceKey, string, bool) error); ok {
		r1 = rf(instanceKey, bindingID, acceptsIncomplete)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
